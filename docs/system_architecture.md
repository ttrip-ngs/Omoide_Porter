# システムアーキテクチャ

## 1. 全体構成

本アプリケーションは、コアロジックを共有するライブラリ層と、それを利用するGUI層およびCUI層から構成されます。

```mermaid
graph TD
    A[コアロジックライブラリ] --> B(GUIアプリケーション);
    A --> C(CUIアプリケーション);
    D[設定ファイル] --> A;
    E[ファイルシステム] --> A;
    F[メタデータ抽出ライブラリ] --> A;
    G[ハッシュ計算ライブラリ] --> A;
    H[デバイス管理層] --> A;
    I[MTP/PTPライブラリ] --> H;
    J[USB通信ライブラリ] --> H;
    B --> K{OS API (Win/Mac)};
    C --> K;
    H --> K;
```

- **コアロジックライブラリ**: ファイル操作、メタデータ解析、フォルダ構造生成、重複検知、ファイル名変更など、アプリケーションの主要な処理を担当します。プラットフォーム非依存の言語（例: Python, Rust, Goなど）での実装を検討します。
- **デバイス管理層**: USB接続されたデバイス（iPhone、Android、デジタルカメラ等）の検出、認識、通信を管理します。各プラットフォーム固有のAPIを抽象化し、統一されたインターフェースを提供します。
- **GUIアプリケーション**: ユーザーフレンドリーなインターフェースを提供し、設定の作成・編集、コピー操作の実行、進捗表示、デバイス選択などを行います。クロスプラットフォームGUIフレームワーク（例: Electron, Qt, Tauriなど）の利用を検討します。
- **CUIアプリケーション**: コマンドラインからの操作を提供し、設定ファイルに基づいたバッチ処理や自動化を可能にします。コアロジックライブラリを直接利用するシンプルな実行ファイルとして実装します。
- **設定ファイル**: フォルダ構造のルール、ファイル名の命名規則、コピー先情報、デバイス固有設定などを保存します。JSONやYAML形式を検討します。

## 2. 使用技術スタック（候補）

| コンポーネント          | 技術候補                                       | 備考                                                                 |
|-------------------------|------------------------------------------------|----------------------------------------------------------------------|
| コアロジック          | Python, Rust, Go                               | パフォーマンス、ライブラリの豊富さ、クロスコンパイルの容易性などを考慮       |
| GUIフレームワーク       | PySide6/PyQt6, Electron + React, Tauri + React | PySide6: Qt公式のPythonバインディング（LGPL v3）。Electron: Web技術利用。Tauri: Rust製、軽量 |
| メタデータ抽出        | exifread, pillow, tinytag (Python), FFprobe    | Pythonライブラリ群＋FFprobeで動画メタデータもカバー                    |
| ファイルハッシュ        | 各言語標準ライブラリ (SHA-256, MD5など)          | cryptographyライブラリ（Python）、標準ライブラリ（Rust/Go）           |
| 設定ファイル形式      | JSON, YAML                                     | 可読性、記述の容易性。PyYAML（Python）、serde（Rust）など             |
| パッケージ管理・配布  | Poetry（Python）, Cargo（Rust）, pip/pipenv    | 依存関係管理、仮想環境、配布パッケージ作成                           |
| ビルド・配布ツール    | PyInstaller, cx_Freeze, cargo-dist, GoReleaser | 単一実行ファイル作成、クロスプラットフォーム配布                      |
| ファイルウォッチング  | watchdog (Python), notify-rust (Rust)         | フォルダ監視、リアルタイム更新検知                                   |
| 並列処理              | asyncio, threading (Python), tokio (Rust)      | 非同期I/O、並列ファイル処理                                          |
| ログ管理              | loguru (Python), tracing (Rust), zap (Go)     | 構造化ログ、ログレベル管理、ファイル出力                             |
| テストフレームワーク  | pytest (Python), cargo test (Rust), testing (Go) | ユニットテスト、結合テスト                                           |
| デバイス通信（iOS）   | libimobiledevice, pymobiledevice3                  | iOSデバイスとの通信、AFC（Apple File Conduit）プロトコル            |
| デバイス通信（Android）| libmtp, android-file-transfer                     | Android MTPプロトコル、ADBインターフェース                          |
| デバイス通信（Camera） | libgphoto2, ptplib                                | PTP（Picture Transfer Protocol）、デジタルカメラ通信               |
| USB管理              | pyusb, libusb, windows-rs (Windows), IOKit (macOS) | USBデバイス検出、低レベルUSB通信                                    |

## 3. データフロー（コピー処理の例）

### 3.1 従来のフォルダコピー

1.  ユーザーがGUIまたはCUIを通じてコピー処理を開始します（設定を指定）。
2.  指定された入力フォルダ内のファイルがスキャンされます。
3.  各ファイルについて、メタデータが抽出されます。
4.  設定に基づいて、出力先のフォルダパスとファイル名が決定されます。
5.  コピー先に同名ファイルが存在する場合、ファイルハッシュを計算し、重複をチェックします。
    - 重複する場合: 設定に従いスキップまたは上書き（ファイル名変更を伴う場合あり）。
    - 重複しない場合: コピーを実行。
6.  関連ファイル（メタデータファイルなど）も同様に処理されます。
7.  処理結果（成功、失敗、スキップなど）がログに記録され、GUIに表示されます。

### 3.2 デバイス接続時のコピー

1.  アプリケーション起動時または定期的に、接続されたUSBデバイスをスキャンします。
2.  MTP/PTP対応デバイスを検出し、デバイス情報（名前、モデル、容量等）を取得します。
3.  ユーザーがデバイスを選択すると、デバイス固有のフォルダ構造を解析します。
4.  必要に応じて、デバイス認証（iOS: 信頼、Android: MTPモード選択）を案内します。
5.  デバイス内のメディアファイルをスキャンし、メタデータを抽出します。
6.  従来のフォルダコピーと同様のフロー（4-7）で処理を実行します。
7.  処理中のデバイス切断を監視し、エラー時は適切な復旧処理を行います。 